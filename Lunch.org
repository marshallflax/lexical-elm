* Elm Lunch-and-Learn -- [[https://github.com/marshallflax/lexical-elm/][https://github.com/marshallflax/lexical-elm/]]
** What is [[http://elm-lang.org/][Elm]]?
*** [[https://en.wikipedia.org/wiki/Functional_reactive_programming][Functional Reactive Programming]]
**** Pure functions -- no side effects ever.
**** System reacts to events (UI actions, Websocket messages, etc)
*** Compiles to Javascript on the browser
*** Efficient language-enforced Model/View/Controller framework
*** Very strongly typed
**** ClassCastException impossible
**** NullPointerException impossible
**** Generics enforced by compiler
**** Missing "case" statement in "switch" impossible
**** Actually-strong typing enables "semantic versioning"
***** Major.minor.patch
***** If the API provided by a package is unchanged, bump the "patch"
***** If the API is increased, bump the "minor"
***** If an existing interface is changed, bump the "major"
**** Subset of Haskell, but without higher-order types or laziness
** What is a functional programming language?
*** In a functional language all data is *immutable*
**** Managing state is always the hard part
***** Common bug: thread-safety
***** Common bug: display after incremental updates doesn't match refresh
***** Common bug: object A references object B, which changes unexpectedly (from A's POV)
**** OO restricts who can modify state, but:
***** Thread-safety is hard
***** Observing an object is error-prone
***** No language-level support for immutable objects
*** Functional languages there are no "variables", only new "final" values
*** Avoid confusions!
**** No confusion between ":=" and "="
**** No confusion between "=" and "=="
**** No confusion between final and immutable
** What is a reactive framework?
*** Elm architecture based on three functions
**** command + current_model => new_model + [new_commands]
**** model => view
**** view => [new_commands]
*** But also, MexicoMarker/MagicMarker/FeedInfo/eBlotter are a reactive framework
**** Engine receives commands and emits updates.
*** Rendering ("view") is always downstream, except that it emits messages to the engine
** Q: But how can this work? A: _Persistent Data Structures_
*** Classic example is the singly-linked list
**** The empty list [] is immutable
**** Prepending -- "a" :: [] -- creates a new immutable list of length 1
**** Prepending again -- "b" :: ("a" :: []) creates a new list of len 2
**** I can prepend "c" to ["b" "a"] and you can prepend "d" to ["b" "a"]
***** The tail of my ["c" "b" "a"] and the tail of your ["d" "b" "a"] are the same
**** Utterly thread-safe ... only the Javascript-level GC has to be correct
*** Also: Sets, Maps, Arrays
**** Very smart algorithms behind the scenes
***** Inserting into a heap involves moving around mostly-unchanged subtrees
***** Since related datastructures share most data, comparison can be *fast*
**** Map/Reduce approach to processing data yields hotspot-friendly code
***** "Fold" is the standard "Reduce" operation.
** Q: But how can this work? A: *Union Types* (also known as _Algebraic Data Structures_)
*** Classic example: Maybe d = Nothing | Just d
**** (Maybe String) is *either*
***** _Just String_ -- i.e. (Just "Hello World!"), _or_
***** _Nothing_ -- i.e. we have no data
**** Every code that processes a "Maybe" *must* handle both cases
**** NullPointerExceptions impossible
*** Other examples
**** SessionCommand = LoginCommand String String | LogoutCommand
**** Result = Err reason | Ok value
** Q: But how can this work? A: Records
*** info1 = {a: 2, b: 23, c: "Hello"}; info2 = {info1 | b = 4}
*** Type system is smart..deduces {a: Int, b: Int, c: String}
**** But explicit declarations will help you when you're confused
**** Sometimes hard to get code to compile, since type system has no humor
***** But hard to write bugs that pass the compiler...a fair trade!!!
** A sample program -- using [[http://localhost:8000/src/Main.elm][elm-reactor]] to dynamically redeploy
*** Top-level
**** Main: [[file:src/Main.elm][Main.elm]] : initial_model, updating_model, view, subscriptions
**** Types: [[file:src/Types.elm][Types.elm]] : Model contains state; Msg is ADT of commands
**** Controller: [[file:src/State.elm][State.elm]] : How commands create a new model from old model
**** View: [[file:src/View.elm][View.elm]] : How to construct HTML from the model**
*** One module
**** [[file:src/FreqInfo.elm][FreqInfo.elm]] : Business logic for some analytics
**** [[file:src/FreqInfoView.elm][FreqInfoView.elm]] : How to render above analytics
*** Another module
**** [[file:src/ColoredWord.elm][ColoredWord.elm]] : Splitting into words and colors
**** [[file:src/ColoredWordView.elm][ColoredWordView.elm]] : Rendering the above
