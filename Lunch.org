* Elm Lunch-and-Learn -- [[https://github.com/marshallflax/lexical-elm/][https://github.com/marshallflax/lexical-elm/]]
* What is [[http://elm-lang.org/][Elm]]?
** Open-source language for developing HTML5 UIs
** Designed to be easy to use, and easy to use _correctly_
** Compiles to Javascript on the browser
** Efficient language-enforced Model/View/Controller framework
** Very strongly typed
*** NullPointerException impossible
*** ClassCastException impossible
*** Generics enforced by compiler
*** Missing "case" statement in "switch" impossible; no "default" case.
*** Strong typing enables "semantic versioning" of libraries
**** Major.minor.patch
**** If the API provided by a package is unchanged, bump the "patch"
**** If the API is increased, bump the "minor"
**** If an existing interface is changed, bump the "major"
*** Contains a subset of Haskell, but without higher-order types or laziness
** [[https://en.wikipedia.org/wiki/Functional_reactive_programming][Functional Reactive Programming]]
* What is "Functional Reactive Programming"?
** In a functional language *all* data is _immutable_
*** Pure functions -- no side effects ever.
*** System reacts to events (UI actions, Websocket messages, etc)
*** Managing state is always the hard part
**** Common bug: thread-safety
**** Common bug: display after incremental updates doesn't match refresh
**** Common bug: object A references object B, which changes unexpectedly (from A's POV)
*** OO restricts who can modify state, but:
**** Thread-safety is hard
**** Observing an object is error-prone
** Functional languages there are no "variables", only new "final" values.
** Avoid many confusions!
*** No confusion between  = and ==
**** No confusion between := and =
*** No confusion between final and immutable
* What is a reactive framework?
** Elm architecture based on three functions
*** How to update the current state
   : (new_model, new_commands) = f(command, current_model)
*** How to render the current state
   : view = g(model)
*** How to create commands
**** Commands triggers can be part of view elements (e.g. <button>)
**** Commands can be defined as part of websocket or http calls
** But also, MexicoMarker/MagicMarker/eBlotter are a reactive framework
*** Engine receives commands and emits updates.
** Rendering ("view") is always downstream, except that it emits messages to the engine
* But how can this work? _Persistent Data Structures_
** Classic example is the singly-linked list
*** The empty list [] is immutable
*** Prepending -- "a" :: [] -- creates a new immutable list of length 1
*** Prepending again -- "b" :: ("a" :: []) creates a new list of len 2
*** I can prepend "c" to ["b" "a"] and you can prepend "d" to ["b" "a"]
**** The tail of my ["c" "b" "a"] and the tail of your ["d" "b" "a"] are the same
*** Utterly thread-safe ... only the Javascript-level GC has to be correct
** Also: Sets, Maps, Arrays
*** Smart algorithms behind the scenes
**** Inserting into a heap involves moving around mostly-unchanged subtrees
**** Since related datastructures share most data, comparison can be *fast*
**** Typical: [[https://en.wikipedia.org/wiki/Zipper_(data_structure)][zipper]] that keeps track of location within the data structure
*** Map/Reduce approach to processing data yields hotspot-friendly code
**** "Fold" is the standard "Reduce" operation.
* But how can this work? Lots of recursive function calls.
*** Loops implemented through recursion
*** Tail Call Optimization allows us to avoid blowing-out the stack
* But how can this work? Union Types
** Classic example:
   : Maybe d = Nothing | Just d
*** (Maybe String) is *either*
**** _Just String_ -- i.e. (Just "Hello World!"), _or_
**** _Nothing_ -- i.e. we have no data
*** Every code that processes a "Maybe" *must* handle both cases
*** NullPointerExceptions caught at compile time
** Other examples
*** Hold either two strings (for login) or zero strings (for logout)
    : SessionCommand = LoginCommand String String | LogoutCommand
*** Either an Error (with reason) or Success (with value)
    : Result = Err reason | Ok value
*** The events that a UI processes [[file:src/Types.elm::EnableAllColors]]
** (also known as _Algebraic Data Structures_)
* But how can this work? Records
** Define records as a structure
  : info1 = {a: 2, b: 23, c: "Hello"}
** Create a new record based on the old one, but with a new value
  : info2 = {info1 | b = 4}
** Type system is smart..deduces {a: Int, b: Int, c: String}
*** But explicit declarations will help you when you're confused
*** Sometimes hard to get code to compile, since type system has no humor
**** But hard to write bugs that pass the compiler...a fair trade!!!
* But how can this work? Explicit contexts
** Computations are "carried along" (essentially on the call stack) until they become effective
** Syntactic sugar
** Also known as [[https://en.wikipedia.org/wiki/Monad_(functional_programming)][Monads]]
* But how can this work? Virtual DOM, so the real DOM is write-only
** Javascript engines are awfully fast -- especially with "clean" javascript
** DOM interaction is still slow -- the rendering engine keeps being asked to do more and more
** Elm does double-buffering against a "Virtual DOM"
*** Computes the delta and sends exactly that to the actual DOM
*** The actual DOM is write-only ... any reads are from the Virtual DOM
**** Events do contain info from the actual DOM of course
* Modular Structure
** Modules declare what they export and what they import
*** Cyclic dependencies result in a compilation error
*** Simple module structure: only "private" and "public" functions -- no "package" or "protected"
*** Modules may be in a flat directory or moved into subdirectories (if the app is large enough)
** A sample program -- using [[http://localhost:8000/src/Main.elm][elm-reactor]] to dynamically redeploy [[file+emacs:src/]]
*** Top-level
**** Main: [[file:src/Main.elm]] : initial_model, updating_model, view, subscriptions
**** Types: [[file:src/Types.elm]] : Model contains state; Msg is ADT of commands
**** Controller: [[file:src/MainController.elm]] : How commands create a new model from old model
**** View: [[file:src/MainView.elm]] : How to construct HTML from the model**
*** One module
**** [[file:src/FreqInfo.elm][FreqInfo.elm]] : Business logic for some analytics
**** [[file:src/FreqInfoView.elm][FreqInfoView.elm]] : How to render above analytics
*** Another module
**** [[file:src/ColoredWord.elm][ColoredWord.elm]] : Splitting into words and colors
**** [[file:src/ColoredWordView.elm][ColoredWordView.elm]] : Rendering the above
*** TDD example
**** [[file:src/BowlingScore.elm][Bowling Kata]]
**** [[file:src/BowlingScoreTest.elm]]
**** [[file:src/BowlingScoreView.elm][BowlingScoreView.elm]]
* Caveats
** Package manager doesn't understand NTLM-based proxies,  so we'll have to setup some sort of reverse proxy
** Learning curve exists for the language -- will take a week or two -- but:
*** Learning curve for new developers to the resulting application will be easier
*** Helps improve our coding approaches in general
** HTML tags are simply Elm functions.
*** For tabular data, this is actually quite nice
*** For complex entry screens, not so nice
**** Unless we can actually define the layout though *data* and stylesheets, in which case it becomes nice again
** Language is only five years old
*** But runtime is just vanilla JavaScript, and the browser is mature
*** Compiler is written in Haskell, which is very mature and robust
** Widget library is still developing
*** New widgets can be written using pure Elm
** View is simply native HTML layout -- lack of tools to graphically edit them
* Time travel! [[http://localhost:8000/src/Main.elm]]
#+OPTIONS: toc:nil
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
